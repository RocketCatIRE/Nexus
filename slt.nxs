{"name":"slicer tools","enabled":true,"description":"A hacking suite for Nexus","type":"group","id":1,"items":[{"type":"function","name":"onLoad","enabled":true,"id":7,"code":"send_command('sltgo')"},{"type":"function","name":"onGMCP","enabled":true,"id":18,"code":"if (typeof slt == 'undefined') return;\n\nvar m = args.gmcp_method;\nvar r = args.gmcp_args;\n\nswitch (m) {\n\tcase 'Room.Info':\n        if (slt.hacking) return;\n        slt.previousRoom = slt.currentRoom;\n        slt.currentRoom = r['num'];\n        slt.currentArea= r['area']; //TODO: ??\n        slt.addTerminal();\n        break;\n\tcase 'Char.Items.List':\n        slt.itemsHere = r['items'];\n        slt.processorHere = false;\n        if (slt.hacking) {\n            slt.calcHere();\n        }\n        break;\n    case 'Char.Items.Remove':\n        break;\n    case 'Char.Items.Add':\n        break;\n    default:\n        break;\n}\n"},{"type":"group","name":"Functions","enabled":true,"id":11,"items":[{"type":"function","name":"slt.main","enabled":true,"id":8,"code":"//slt.main\nslt = typeof slt != 'undefined' ? slt : {}\n//display_notice('nvar was:'+ JSON.stringify(get_variable('slt.db')));\nslt.db = get_variable('slt.db') || {}\n//display_notice('memory:'+ JSON.stringify(slt.db));\n//display_notice('nvar is:'+ JSON.stringify(get_variable('slt.db')));\n//slt.db = {}\nslt.currentRoom = '';\nslt.previousRoom = '';\nslt.currentArea = '';\nslt.itemsHere = [];\nslt.hacking = false;\nslt.deleteConfirmState = false;\nslt.processorHere = false;\nslt.termDescs = {\n    'an unobtrusive access terminal':1,\n    'a biometric access terminal':1,\n    'an ancient access terminal':1,\n    'a reinforced access terminal':1,\n}\nslt.addTerminal = function() {\n\tvar r = slt.itemsHere;\n\tfor (var i = 0, noe = r.length; i<noe;i++) {\n\t\tif (!(r[i]['name'] in slt.termDescs)) continue;\n\t\tif (!(slt.currentRoom in slt.db)) {\n\t\t\tvar id = r[i]['id'];\n\t\t\tvar desc = r[i]['name'];\n\n\t\t\tslt.db[slt.currentRoom] = {\n\t\t\t\t'desc':desc,\n\t\t\t\t'level':null,\n\t\t\t\t'id':id,\n\t\t\t\t'area':slt.currentArea,\n\t\t\t\t'ready':true,\n\t\t\t\t'readyDate':null,\n\t\t\t\t'primary':true,\n\t\t\t\t'linkedTo':[],\n\t\t\t}\n\t\t\tsend_command('l ' +id); //Grab the hacking level\n\t\t\tslt.hardSave();\n\n\t\t}\n\t}\n}\n\nslt.getTerminalsByLevel = function(lvl, testRdy) {\n\tvar testRdy = testRdy || false;\n\tvar output = {};\n\tfor (key in slt.db) {\n\t\tvar t = slt.db[key];\n\t\tif (testRdy) {\n\t\t\tif (!t.ready) continue;\n\t\t}\n\t\tif (slt.settings.gaglinked.val) {\n\t\t\tif (!t.primary) continue;\n\t\t}\n\t\tif (t.level == lvl) {\n\t\t\toutput[key] = slt.db[key];\n\t\t}\n\t}\n\treturn output;\n}\nslt.getTerminalsByLevelRange = function(min, max, testRdy) {\n\tvar testRdy = testRdy || false;\n\tvar output = {};\n\tfor (key in slt.db) {\n\t\tvar t = slt.db[key]\n\t\tif (testRdy) {\n\t\t\tif (!t.ready) continue;\n\t\t}\n\t\tif (slt.settings.gaglinked.val) {\n\t\t\tif (!t.primary) continue;\n\t\t}\n\t\tif ((min <= t.level) && (t.level <= max)) {\n\t\t\toutput[key] = slt.db[key];\n\t\t}\n\t}\n\treturn output;\n}\nslt.getTerminalsByArea = function(area, testRdy) {\n\tvar testRdy = testRdy || false;\n    var area = area.toLowerCase();\n\tvar output = {};\n    slt.verb('Getting terminals with area key: \"'+area+'\"');\n\tfor (key in slt.db) {\n\t\tvar t = slt.db[key];\n\t\tif (testRdy) {\n\t\t\tif (!t.ready) continue;\n\t\t}\n\t\tif (slt.settings.gaglinked.val) {\n\t\t\tif (!t.primary) continue;\n\t\t}\n\t\tif (t.area.toLowerCase() == area) {\n\t\t\toutput[key] = slt.db[key];\n\t\t}\n\t}\n\treturn output;\n}\n\nslt.deleteTerminal = function(t) {\n\tvar t = t.toLowerCase();\n\tif ((t == 'confirm') && slt.deleteConfirmState) {\n\t\tdelete_variable('slt.db');\n\t\tslt.db = {};\n\t\tslt.deleteConfirmState = false;\n\t\tslt.report('Deleted the terminal database')\n\n\t} else if (t == 'all') {\n\t\tslt.deleteConfirmState = true;\n\t\tsetTimeout(function(){slt.deleteConfirmState=false;},1000*10)\n\t\tslt.report('You are about to delete the terminal database, this will delete all terminal data and is irreversible. SLT DELETE CONFIRM to proceed.');\n\t\treturn;\n\n\t} else if (t in slt.db) {\n\t\tvar tdb = slt.db[t]\n        \n\t\tif (tdb.linkedTo != '') {\n            \n\t\t\tvar t2 = slt.db[tdb.linkedTo];\n\t\t\tt2.linkedTo = '';\n\t\t\tt2.primary = true;\n\t\t\tslt.report('Terminal '+ slt.coemph(t.linkedTo) + 'delinked from ' +slt.coemph(t))\n            \n\t\t}\n\t\tdelete tdb;\n\t\tslt.report('Terminal ' + slt.coemph(t) + ' deleted from database.');\n\t\tslt.hardSave();\n\t} \n    else {\n\t\tslt.error('Invalid value for delete: ' +t);\n\t}\n}\n\nslt.hardSave = function() {\n\tset_variable('slt.db', slt.db);\n\tset_variable('slt.settings', slt.settings);\n\tslt.verb('&check;Saved slt');\n}\nslt.termLink = function(t1, t2, bool) {\n\tvar t1 = t1.toLowerCase();\n\tvar t2 = t2.toLowerCase();\n\tif (t1 == 'here') {\n\t\tvar here = slt.currentRoom;\n\t\tif (here in slt.db) {\n\t\t\tt1 = here;\n\t\t} else {\n\t\t\tslt.error('There is no terminal here.')\n\t\t\treturn false;\n\t\t}\n\t} else if (t1 == 'previous') {\n\t\tvar prev = slt.previousRoom;\n\t\tif (prev in slt.db) {\n\t\t\tt1 = prev;\n\t\t} else {\n\t\t\tslt.error('There was no terminal in the previous room.')\n\t\t\treturn false;\n\t\t}\n\n\t}\n\tif (t2 == 'here') {\n\t\tvar here = slt.currentRoom;\n\t\tif (here in slt.db) {\n\t\t\tt2 = here;\n\t\t} else {\n\t\t\tslt.error('There is no terminal here.')\n\t\t\treturn false;\n\t\t}\n\t} else if (t2 == 'previous') {\n\t\tvar prev = slt.previousRoom;\n\t\tif (prev in slt.db) {\n\t\t\tt2 = prev;\n\t\t} else {\n\t\t\tslt.error('There was no terminal in the previous room.')\n\t\t\treturn false;\n\t\t}\n\n\t}\n\tif (!(t1 in slt.db)) {\n\t\tslt.error('No terminal found for room ' + t1);\n\t\treturn false;\n\t}\n\tif (!(t2 in slt.db)) {\n\t\tslt.error('No terminal found for room ' + t2);\n\t\treturn false;\n\t}\n\tvar tPrimary = slt.db[t2];\n\tvar tSecondary = slt.db[t1];\n\ttPrimary.linkedTo.push(t1);\n\ttSecondary.linkedTo.push(t2);\n\ttPrimary.primary = true;\n\ttSecondary.primary = false;\n\tslt.report('Terminal '+t1+' linked as a secondary terminal to terminal '+t2);\n\tslt.hardSave();\n\treturn true;\n}\n\nslt.termUnlink = function(t) {\n\tif (!(t in slt.db)) {\n\t\tslt.error('No terminal ' + t + ' found in slt database.');\n\t\treturn false;\n\t}\n\tvar term = slt.db[t];\n\tvar linkedTo = term.linkedTo;\n\tif (linkedTo == []) {\n\t\tslt.error('Terminal ' + t + ' is not linked to any terminal.');\n\t\treturn false;\n\t}\n    var links = {}\n    for (var i = 0, noe = linkedTo.length; i<noe;i++) {\n        links[linkedTo[i]] = slt.db[linkedTo[i]];\n    }\n\tterm.primary = true;\n\tterm.linkedTo = [];\n    for (var key in links) {\n        for (var i = 0, noe = links[key].linkedTo.length; i<noe;i++) {\n            if (links[key].linkedTo[i] == t) {\n                links[key].linkedTo.splice(i,1);noe--;i--;\n                if (links[key].linkedTo.length == 0)links[key].primary = true;\n            }\n        }\n    }\n\tslt.report('Terminal '+t+' unlinked');\n\tslt.hardSave();\n\treturn true;\n}\n\nslt.hackTimer = function(t, secs, failed, recent) {\n\tif (!(t in slt.db)) {\n\t\tslt.error('Error: hack timer update was called for an unknown terminal ' +t);\n\t\treturn false;\n\t}\n\tvar ms = secs*1000;\n\tvar failed = failed || false;\n    var recent = recent || false;\n\tvar now  = new Date().getTime()\n    slt.verb('It is now in ms ' +now);\n\tvar ready = new Date(now+ms).getTime();\n    slt.verb('Ready in ss ' +ready);\n\tslt.db[t].readyDate = ready;\n    slt.db[t].ready = false;\n\tslt.report('Terminal at vNum '+slt.coemph(t) + ' may be hacked again on ' + slt.coemph(new Date(ready).toLocaleString()));\n    if (recent) {\n        if (typeof slt.timeouts[t] != 'undefined') {\n            clearTimeout(slt.timeouts[t]);\n        }\n        slt.timeouts[t] = setTimeout(slt.checkHackTimers, (parseInt(recent)*1000)+1000);\n    }\n\tslt.hardSave();\n}\n\nslt.checkHackTimers = function() {\n\tvar now = new Date().getTime()\n\tfor (t in slt.db) {\n\t\tvar rdyOn  = slt.db[t].readyDate\n\t\tif (rdyOn == null) continue;\n\t\tvar diff = rdyOn - now; // if diff is positive, not ready. If diff is 0 or negative, ready.\n\t\tif (diff > 0) continue;\n\t\t//terminal is ready again.\n\t\tslt.db[t].readyDate = null;\n\t\tslt.db[t].ready = true;\n        if (slt.db[t].primary) {\n            slt.report('Level '+ slt.coemph(slt.db[t].level) + ' terminal vNum '+ slt.coemph(t) +' in '+slt.coemph(slt.db[t].area) +' is ready to hack again.')\n        } else if (slt.settings.gaglinked.val) {\n            slt.report('Level '+ slt.coemph(slt.db[t].level) + ' terminal vNum '+ slt.coemph(t) +' in '+slt.coemph(slt.db[t].area) +' is ready to hack again.')\n        }\n\t}\n\tslt.hardSave();\n    slt.verb('&check;Ran timer check')\n}\n\nslt.timerInterval = function() {\n    if (typeof slt.interval != 'undefined') clearInterval(slt.interval);\n    slt.interval = setInterval(slt.checkHackTimers, 1000*slt.settings.check_timer_interval.val)\n\n}"},{"type":"function","name":"slt.display","enabled":true,"id":19,"code":"slt = typeof slt != 'undefined' ? slt : {}\n//slt display <level|level_range|area|NEARBY|ALL> [READY]\nslt.display = function(key, testRdy) {\n\tvar re = /^\\d\\d?$/;\n\tvar key = key.toLowerCase();\n\tvar testRdy = testRdy || false;\n    if (testRdy) testRdy = testRdy.toLowerCase()\n\ttestRdy = testRdy == 'ready' ? true : false\n\tvar table = null;\n\tif (re.test(key)) {\n\t\ttable = slt.getTerminalsByLevel(parseInt(key), testRdy);\n\t} else if (key.split('-').length > 1) {\n\t\tvar min = key.split('-')[0];\n\t\tvar max = key.split('-')[1];\n\t\tif (!re.test(min) || !re.test(max)) {\n\t\t\tslt.error('Invalid level range ' + key);\n\t\t\treturn false;\n\t\t}\n\t\tmin = parseInt(min);\n\t\tmax = parseInt(max);\n\t\tif (min > max) {\n\t\t\tslt.error('The first value in the range should be smaller than the second');\n\t\t\treturn false;\n\t\t}\n\t\ttable = slt.getTerminalsByLevelRange(min, max, testRdy);\n\t} else if ((key == 'nearby') || (key == 'here')) {\n\t\ttable = slt.getTerminalsByArea(slt.currentArea, testRdy);\n\t} else if (key == 'all') {\n\t\ttable = slt.getTerminalsByLevelRange(0,99,testRdy);\n\t} else if (key.split('.').length >1) {\n\t\ttable = slt.getTerminalsByArea(key.split('.').join(' '),testRdy);\n\t} else{\n\t\tslt.error('Invalid option for terminal display: '+key);\n\t\treturn false;\n\t}\n    slt.verb('Found results: '+ JSON.stringify(Object.keys(table)));\n\tvar output = {};\n\toutput.title = 'Slicer Tools: Terminal Database'\n\toutput.heading = ['vNum', 'level','area','ready','readyDate','primary','linkedTo'];\n\toutput.rows = []\n\tfor (key in table) {\n\t\tvar row = [];\n\t\trow.push('$'+key+'$');\n\t\trow.push(table[key].level);\n\t\trow.push(table[key].area.substring(0,30));\n        row.push(table[key].ready);\n\t\tif (table[key].readyDate != null) {\n            row.push(new Date(table[key].readyDate).toLocaleString());\n        } else {\n            row.push('');\n        }\n\t\trow.push(table[key].primary);\n        row.push(JSON.stringify(table[key].linkedTo));\n\t\toutput.rows.push(row);\n\t}\n    \n\tvar final = AsciiTable.factory(output);\n    final.sort(function(a, b) {\n \t\t return a[2] - b[2]\n\t})\n\tfinal.sort(function(a, b) {\n \t\t return b[1] - a[1]\n\t})\n\tslt.tableReport(final);\n}\n\nslt.displayHelp = function() {\n\tslt.report(slt.comsg('<span class=\"mono\">=============DATABASE COMMANDS===========</span>'))\n    slt.report(slt.comsg('SLT: ')+slt.cofalse('Display this summary'))\n    slt.report(slt.comsg('SLT DISPLAY &lt;ALL|NEARBY/HERE|level|level_range|area&gt; [READY]: ')+slt.cofalse('Display terminals in the database. NEARBY/HERE checks the current area. Level displays all of that level. Level range input should be formatted as such: \"10-16\". Area input should use periods instead of spaces, i.e. \"Litharge,.the.Celestine.Ascendancy\\'s.Capital\". Specify READY if you only want terminals which are currently hackable.'))\n    slt.report(slt.comsg('SLT LINK &lt;num|HERE/PREVIOUS&gt; to &lt;num|HERE/PREVIOUS&gt;: ')+slt.cofalse('Indicate to the database that two terminals share the same timer, often front-door/back-door terminals, but sets of more than 2 exist. The first input value will become a secondary terminal, which are by default gagged from the display results (see SLT SETTINGS). Multiple terminals may be specified as secondary to a primary terminal.'))\n    slt.report(slt.comsg('SLT UNLINK &lt;term&gt;: ')+slt.cofalse('Remove any links to and from this terminal. This terminal will again be considered a primary terminal.'))\n    slt.report(slt.comsg('SLT ALL [READY]: ')+slt.cofalse('Short for SLT DISPLAY ALL, but feel free to set aliases if you want something shorter.'))\n    slt.report(slt.comsg('SLT DELETE &lt;term/ALL&gt;: ')+slt.cofalse('Delete a terminal from the database or the entire database. Irreversible.'))\n    slt.report(slt.comsg('SLT SETTINGS: ')+slt.cofalse('Display the available user settings.'))\n    slt.report(slt.comsg('SLT SET &lt;setting&gt; &lt;value&gt;: ')+slt.cofalse('Set a user setting to the specified value.'))\n    slt.report(slt.comsg('SLT SETTINGS DEFAULT: ')+slt.cofalse('Return user settings to default values.'))\n    slt.report(slt.comsg('HT: ')+slt.cofalse('Hack terminal.'))\n\tslt.report(slt.comsg('<span class=\"mono\">=============COMMSPHERE TOOLS============</span>'))\n    slt.report(slt.comsg('PASS: ')+slt.cofalse('Check the current password hint against a dictionary of 370,101 Galactic Standard words, by default the system will auto-unlock if there is only 1 result and you are in or enter the room with the processor.'))\n\tslt.report(slt.comsg('<span class=\"mono\">=============HOW TO======================</span>'))\n    slt.report(slt.cofalse('When you enter a room with a terminal, SLT will add it to its database of terminals if it is not already included. Once added, SLT will manage its hacking timers and inform you when it is ready to hack again.'))\n    \n}"},{"type":"function","name":"slt.utilities","enabled":true,"id":20,"code":"slt = typeof slt != 'undefined' ? slt : {}\nslt.options = {\n    tag : '&Lang;   slt   &Rang;',\n    tagc : 'rgb(229, 202, 172)',\n    msgc : 'rgb(224, 255, 241)',\n    emphc: 'rgb(0, 198, 16)',\n    falc: 'rgb(163, 163, 163)',\n    errc: 'rgb(255, 103, 76)',\n    proc: 'rgb(144, 249, 171)',\n};\n\n\n//<a class='mxp_send' href=' ' style=\"color:#d7ff87'></a> \nslt.mxp = function(str, href) {\n    return \"<a class='mxp_send' href='\"+href+\"'style=\\'color:#d7ff87\\'>\"+str+\"</a>\";\n}\nslt.report = function(msg) { slt.owWrite('#output_main', '<div style=\"color: ' + slt.options.tagc + ';\">' + slt.options.tag + ': <span style=\"color: ' + slt.options.msgc + ';\">' + msg + '</span></div>') };\nslt.tableReport = function(table) { \n    table.options.prefix = '  ';\n    table = table.toString();\n    table = table.replace(/\\$(.+?)\\$/g,\" <a class='mxp_send' href='walk to $1'style=\\'color:#d7ff87\\'>$1</a> \" )\n    table = table.replace(/\\$/g,'');\n    slt.owWrite('#output_main', '<div class=\"mono\">'+ slt.cofalse(table)+'</div>'); \n};\nslt.error = function(msg) {slt.report(slt.coerr(msg));}\nslt.verb = function(msg) {if(slt.settings.verbose.val){slt.report(msg);}},\nslt.coemph = function(str) {return '<span style=\"color:'+slt.options.emphc+';\"/>'+str+'</span>';}\nslt.coerr = function(str) {return '<span style=\"color:'+slt.options.errc+';\"/>'+str+'</span>';}\nslt.cofalse = function(str) {return '<span style=\"color:'+slt.options.falc+';\"/>'+str+'</span>';}\nslt.coprop = function(str) {return '<span style=\"color:'+slt.options.proc+';\"/>'+str+'</span>';}\nslt.cotag = function(str) {return '<span style=\"color:'+slt.options.tagc+';\"/>'+str+'</span>';}\nslt.comsg = function(str) {return '<span style=\"color:'+slt.options.msgc+';\"/>'+str+'</span>';}\n\n\nslt.owWrite = function(selector, text) {\n    if (text.trim() == \"\") return;\n\n    // doing these updates asynchronously to minimize reflows when under heavy load\n    window.requestAnimationFrame(function() {\n        var hooks = $.cssHooks;\n        $.cssHooks = {};\n\n        var output = client.document.querySelectorAll(selector + ' .output')[0];\n        var newel = document.createElement('div');\n        newel.innerHTML = text;\n        newel.className = 'line';\n        newel.id = 'msg' + num_msgs;\n        output.appendChild(newel);\n        if(client.logging){append_to_log(newel.innerHTML);}\n\n        var scrollback = client.document.querySelectorAll(selector + ' .output_scrollback')[0];\n        newel = document.createElement('div');\n        newel.className = 'line';\n        newel.innerHTML = text;\n        newel.id = 'sb_msg' + num_msgs;\n        scrollback.appendChild(newel);\n\n        trim_ow(selector);\n\n        num_msgs++;\n        scrollback_num_msgs++;\n\n        if (selector === '#output_main') {\n           if (no_prompts || gag_prompts) {\n               var el = client.document.querySelectorAll('#output_main .prompt');\n               for (var i = 0; i < el.length; i++) el[i].style.display = 'none';\n               // last prompt shown?\n               if ((!no_prompts) && el.length > 0)\n                   el[el.length - 1].style.display = 'block';\n           }\n           if (show_timestamps) {\n               var el = client.document.querySelectorAll('#output_main .output #msg'+(num_msgs-1)+' .timestamp');\n               for (var i = 0; i < el.length; i++) el[i].classList.remove('no_out');\n           }\n           if (show_scroll_timestamps) {\n               var el = client.document.querySelectorAll('#output_main .output_scrollback #sb_msg'+(num_msgs-1)+' .timestamp');\n               for (var i = 0; i < el.length; i++) el[i].classList.remove('no_out');\n           }\n        }\n\n        output.scrollTop = output.scrollHeight;\n\n        $.cssHooks = hooks;\n    });\n\n};\n\nslt.report('Slicer tools loaded. Type \"slt\" for help.');"},{"type":"function","name":"slt.interface","enabled":true,"id":22,"code":"slt = typeof slt != 'undefined' ? slt : {}\nslt.interface = function(args) {\n\tvar cmd = args.cmd.toLowerCase();\n\tvar key = args.key || false;\n\tvar val = args.val || false;\n\tvar val2 = args.val2 || false;\n    if (key) key = key.toLowerCase();\n    if (val) val = val.toLowerCase();\n    if (val2) val2 = val2.toLowerCase();\n\tswitch (cmd) {\n\t\tcase 'slt':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.displayHelp()')\n            slt.displayHelp(); //TODO\n            break;\n\t\tcase 'display':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.display')\n            slt.display(key,val);\n            break;\n\t\tcase 'all':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.display')\n            slt.display('all',key);\n            break;\n\t\tcase 'link':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.termLink')\n            slt.termLink(key,val2);\n            break;\n\t\tcase 'unlink':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.termUnink')\n            slt.termUnlink(key);\n            break;\n\t\tcase 'settings':\n            if (key == 'default') {\n            \tslt.verb('Interface found args '+JSON.stringify(args)+', calling slt.defaultSettings')\n                slt.defaultSettings();\n            }\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.displayAllSettings')\n            slt.displayAllSettings();\n            break;\n\t\tcase 'set':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.setSetting')\n            slt.setSetting(key, val);\n            break;\n\t\tcase 'delete':\n            slt.verb('Interface found args '+JSON.stringify(args)+', calling slt.deleteTerminal')\n            slt.deleteTerminal(key);\n            break;\n\t\tdefault:\n            slt.error('Invalid slt command: ' + cmd);\n            break;\n\t}\n}"},{"type":"function","name":"slt.settings","enabled":true,"id":23,"code":"slt = typeof slt != 'undefined' ? slt : {}\nslt.settings = get_variable('slt.settings') || {\n\t'verbose' :  {val:false,desc:'Send additional notifiactions, for debugging purposes. TRUE/FALSE.'},\n\t'gaglinked' : {val:true,desc:'Gag secondary linked terminals from display. TRUE/FALSE.'},\n    'auto_unlock' : {val:true,desc:'Auto UNLOCK if there is only 1 result from dictionary search. TRUE/FALSE.'},\n    'check_timer_interval' : {val:60, desc:'Check the database every x seconds for ready terminals. INTEGER.'},\n    'preload_dict':{val:true,desc:'When false the dictionary (6.4mb) will not be stored in memory. TRUE/FALSE.'},\n    'highlight_gridscan':{val:true,desc:'Conditional highlighting of gridscan results. TRUE/FALSE.'},\n}\n\nslt.defaultSettings = function() {\n    slt.verb('Loading default settings');\n    slt.settings = {\n\t'verbose' :  {val:false,desc:'Send additional notifiactions, for debugging purposes. TRUE/FALSE.'},\n\t'gaglinked' : {val:true,desc:'Gag secondary linked terminals from display. TRUE/FALSE.'},\n    'auto_unlock' : {val:true,desc:'Auto UNLOCK if there is only 1 result from dictionary search. TRUE/FALSE.'},\n    'check_timer_interval' : {val:60, desc:'Check the database every x seconds for ready terminals. INTEGER.'},\n    'preload_dict':{val:true,desc:'When false the dictionary (6.4mb) will not be stored in memory. TRUE/FALSE.'},\n    'highlight_gridscan':{val:true,desc:'Conditional highlighting of gridscan results. TRUE/FALSE.'},\n}\n    slt.hardSave();\n}\n\nslt.setSetting = function(key, val) {\n\tvar key = key.toLowerCase();\n\tvar val = val.toLowerCase();\n    var re = /^\\d+$/;\n\tif (key in slt.settings) {\n\t\tvar k = slt.settings[key]\n\t\tif (val == 'true') {\n\t\t\tk.val = true;\n\t\t\tslt.report('Setting ' + key + ' set to ' + val);\n\t\t} else if (val == 'false') {\n\t\t\tslt.report('Setting ' + key + ' set to ' + val);\n\t\t\tk.val = false;\n\t\t} else if (re.test(val)) {\n\t\t\tslt.report('Setting ' + key + ' set to ' + val);\n            k.val = parseInt(val);\n        } else {\n\t\t\tslt.error('Invalid value ' + val + ' for setting: ' +key)\n\t\t}\n\t} else {\n\t\t\tslt.error('Unknown setting ' + key + '.');\n\t}\n}\n\nslt.displayAllSettings = function() {\n\tvar table = {};\n    table.title = 'Slicer Tools: Settings'\n\ttable.heading = ['Setting', 'Value', 'Description'];\n\ttable.rows = []\n\tfor (key in slt.settings) {\n\t\tvar row = [];\n\t\trow.push(key);\n\t\trow.push(slt.settings[key].val);\n\t\trow.push(slt.settings[key].desc);\n\t\ttable.rows.push(row);\n\t}\n\tvar output = AsciiTable.factory(table);\n\toutput.sort(function(a, b) {\n \t\t return a[0] - b[0]\n\t})\n\tslt.tableReport(output);\n}"},{"type":"function","name":"slt.loadDict","enabled":true,"id":27,"code":"slt = typeof slt != 'undefined' ? slt : {}\nslt.pwRe = null;\n\nslt.loadDict = function(calc) {\nvar urls = [\n 'https://raw.githubusercontent.com/dwyl/english-words/master/words_dictionary.json',\n]\nvar calc = calc || false;\n\n var p = $.when(1)\nurls.forEach(function(item, index) {\n  let a = item\n  slt.verb('Loading Galactic Standard dictionary');\n  p = p.then(function() {\n    return $.ajax({\n     url: a + '?v=' + new Date().getTime()\n    }).done(function(data) {\n      console.log('Trying JSON.parse(data) for ' + a + '.')\n      console.log([data])\n      try {\n       slt.dictionary = JSON.parse(data);\n       if (calc) slt.calcPassword();\n      } catch(err) { console.log(err) }\n    }\n    \n    )\n  })\n})\n}\nslt.calcPassword = function() {\n\tvar results = [];\n\tif (typeof slt.pwRe != 'object') {\n        slt.error('calcPassword found no pattern to match.');\n        return;\n    }\n\tfor (key in slt.dictionary) {\n\t\tif (slt.pwRe.test(key)) results.push(key);\n\t}\n\tvar len = results.length\n\tslt.report('Found ' +slt.coemph(len)+ ' results for current password hint: '+results.join(', '));\n\tif (!slt.settings.auto_unlock.val) return;\n\tif (len == 1) {\n        slt.password = results[0];\n        if (slt.processorHere && slt.settings.auto_unlock.val) send_command('unlock '+results[0]);\n\t}\n    if (!slt.settings.preload_dict) delete slt.dictionary;\n}\n\nif (slt.settings.preload_dict.val) slt.loadDict();"},{"type":"function","name":"slt.calcHere","enabled":true,"id":42,"code":"slt = typeof slt != 'undefined' ? slt : {}\n\nslt.calcHere = function() {\n    var items = slt.itemsHere;\n    var iceHere = false;\n    for (var i=0,noe=items.length;i<noe;i++) {\n        if (items[i].name == \"processor_array\") {\n            slt.processorHere = true;\n            slt.verb('Found the processor');\n            if (!slt.settings.auto_unlock.val) return;\n            if (typeof slt.password != 'undefined') send_command('unlock '+slt.password);\n        }\n    }\n}"},{"type":"function","name":"ascii-tables","enabled":true,"id":53,"code":"//https://raw.githubusercontent.com/sorensen/ascii-table/master/ascii-table.js\n/**\n * (c) 2013 Beau Sorensen\n * MIT Licensed\n * For all details and documentation:\n * https://github.com/sorensen/ascii-table\n */\n\n;(function() {\n'use strict';\n\n/*!\n * Module dependencies\n */\n\nvar slice = Array.prototype.slice\n  , toString = Object.prototype.toString\n\n/**\n * AsciiTable constructor\n *\n * @param {String|Object} title or JSON table\n * @param {Object} table options\n *  - `prefix` - string prefix added to each line on render\n * @constructor\n * @api public\n */\n\nfunction AsciiTable(name, options) {\n  this.options = options || {}\n  this.reset(name)\n}\n\n/*!\n * Alignment constants\n */\n\nAsciiTable.LEFT = 0\nAsciiTable.CENTER = 1\nAsciiTable.RIGHT = 2\n\n/*!\n * Static methods\n */\n\n/**\n * Create a new table instance\n *\n * @param {String|Object} title or JSON table\n * @param {Object} table options\n * @api public\n */\n\nAsciiTable.factory = function(name, options) {\n  return new AsciiTable(name, options)\n}\n\n/**\n * Align the a string at the given length\n *\n * @param {Number} direction\n * @param {String} string input\n * @param {Number} string length\n * @param {Number} padding character\n * @api public\n */\n\nAsciiTable.align = function(dir, str, len, pad) {\n  if (dir === AsciiTable.LEFT) return AsciiTable.alignLeft(str, len, pad)\n  if (dir === AsciiTable.RIGHT) return AsciiTable.alignRight(str, len, pad)\n  if (dir === AsciiTable.CENTER) return AsciiTable.alignCenter(str, len, pad)\n  return AsciiTable.alignAuto(str, len, pad)\n}\n\n/**\n * Left align a string by padding it at a given length\n *\n * @param {String} str\n * @param {Number} string length\n * @param {String} padding character (optional, default '')\n * @api public\n */\n\nAsciiTable.alignLeft = function(str, len, pad) {\n  if (!len || len < 0) return ''\n  if (str === undefined || str === null) str = ''\n  if (typeof pad === 'undefined') pad = ' '\n  if (typeof str !== 'string') str = str.toString()\n  var alen = len + 1 - str.length\n  if (alen <= 0) return str\n  return str + Array(len + 1 - str.length).join(pad)\n}\n\n/**\n * Center align a string by padding it at a given length\n *\n * @param {String} str\n * @param {Number} string length\n * @param {String} padding character (optional, default '')\n * @api public\n */\n\nAsciiTable.alignCenter = function(str, len, pad) {\n  if (!len || len < 0) return ''\n  if (str === undefined || str === null) str = ''\n  if (typeof pad === 'undefined') pad = ' '\n  if (typeof str !== 'string') str = str.toString()\n  var nLen = str.length\n    , half = Math.floor(len / 2 - nLen / 2)\n    , odds = Math.abs((nLen % 2) - (len % 2))\n    , len = str.length\n\n  return AsciiTable.alignRight('', half, pad) \n    + str\n    + AsciiTable.alignLeft('', half + odds, pad)\n}\n\n/**\n * Right align a string by padding it at a given length\n *\n * @param {String} str\n * @param {Number} string length\n * @param {String} padding character (optional, default '')\n * @api public\n */\n\nAsciiTable.alignRight = function(str, len, pad) {\n  if (!len || len < 0) return ''\n  if (str === undefined || str === null) str = ''\n  if (typeof pad === 'undefined') pad = ' '\n  if (typeof str !== 'string') str = str.toString()\n  var alen = len + 1 - str.length\n  if (alen <= 0) return str\n  return Array(len + 1 - str.length).join(pad) + str\n}\n\n/**\n * Auto align string value based on object type\n *\n * @param {Any} object to string\n * @param {Number} string length\n * @param {String} padding character (optional, default '')\n * @api public\n */\n\nAsciiTable.alignAuto = function(str, len, pad) {\n  if (str === undefined || str === null) str = ''\n  var type = toString.call(str)\n  pad || (pad = ' ')\n  len = +len\n  if (type !== '[object String]') {\n    str = str.toString()\n  }\n  if (str.length < len) {\n    switch(type) {\n      case '[object Number]': return AsciiTable.alignRight(str, len, pad)\n      default: return AsciiTable.alignLeft(str, len, pad)\n    }\n  }\n  return str\n}\n\n/**\n * Fill an array at a given size with the given value\n *\n * @param {Number} array size\n * @param {Any} fill value\n * @return {Array} filled array\n * @api public\n */\n\nAsciiTable.arrayFill = function(len, fill) {\n  var arr = new Array(len)\n  for (var i = 0; i !== len; i++) {\n    arr[i] = fill;\n  }\n  return arr\n}\n\n/*!\n * Instance methods\n */\n\n/**\n * Reset the table state back to defaults\n *\n * @param {String|Object} title or JSON table\n * @api public\n */\n\nAsciiTable.prototype.reset = \nAsciiTable.prototype.clear = function(name) {\n  this.__name = ''\n  this.__nameAlign = AsciiTable.CENTER\n  this.__rows = []\n  this.__maxCells = 0\n  this.__aligns = []\n  this.__colMaxes = []\n  this.__spacing = 1\n  this.__heading = null\n  this.__headingAlign = AsciiTable.CENTER\n  this.setBorder()\n\n  if (toString.call(name) === '[object String]') {\n    this.__name = name\n  } else if (toString.call(name) === '[object Object]') {\n    this.fromJSON(name)\n  }\n  return this\n}\n\n/**\n * Set the table border\n *\n * @param {String} horizontal edges (optional, default `|`)\n * @param {String} vertical edges (optional, default `-`)\n * @param {String} top corners (optional, default `.`)\n * @param {String} bottom corners (optional, default `'`)\n * @api public\n */\n\nAsciiTable.prototype.setBorder = function(edge, fill, top, bottom) {\n  this.__border = true\n  if (arguments.length === 1) {\n    fill = top = bottom = edge\n  }\n  this.__edge = edge || '|'\n  this.__fill = fill || '-'\n  this.__top = top || '.'\n  this.__bottom = bottom || \"'\"\n  return this\n}\n\n/**\n * Remove all table borders\n *\n * @api public\n */\n\nAsciiTable.prototype.removeBorder = function() {\n  this.__border = false\n  this.__edge = ' '\n  this.__fill = ' '\n  return this\n}\n\n/**\n * Set the column alignment at a given index\n *\n * @param {Number} column index\n * @param {Number} alignment direction\n * @api public\n */\n\nAsciiTable.prototype.setAlign = function(idx, dir) {\n  this.__aligns[idx] = dir\n  return this\n}\n\n/**\n * Set the title of the table\n *\n * @param {String} title\n * @api public\n */\n\nAsciiTable.prototype.setTitle = function(name) {\n  this.__name = name\n  return this\n}\n\n/**\n * Get the title of the table\n *\n * @return {String} title\n * @api public\n */\n\nAsciiTable.prototype.getTitle = function() {\n  return this.__name\n}\n\n/**\n * Set table title alignment\n *\n * @param {Number} direction\n * @api public\n */\n\nAsciiTable.prototype.setTitleAlign = function(dir) {\n  this.__nameAlign = dir\n  return this\n}\n\n/**\n * AsciiTable sorting shortcut to sort rows\n *\n * @param {Function} sorting method\n * @api public\n */\n\nAsciiTable.prototype.sort = function(method) {\n  this.__rows.sort(method)\n  return this\n}\n\n/**\n * Sort rows based on sort method for given column\n *\n * @param {Number} column index\n * @param {Function} sorting method\n * @api public\n */\n\nAsciiTable.prototype.sortColumn = function(idx, method) {\n  this.__rows.sort(function(a, b) {\n    return method(a[idx], b[idx])\n  })\n  return this\n}\n\n/**\n * Set table heading for columns\n *\n * @api public\n */\n\nAsciiTable.prototype.setHeading = function(row) {\n  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {\n    row = slice.call(arguments)\n  }\n  this.__heading = row\n  return this\n}\n\n/**\n * Get table heading for columns\n *\n * @return {Array} copy of headings\n * @api public\n */\n\nAsciiTable.prototype.getHeading = function() {\n  return this.__heading.slice()\n}\n\n/**\n * Set heading alignment\n *\n * @param {Number} direction\n * @api public\n */\n\nAsciiTable.prototype.setHeadingAlign = function(dir) {\n  this.__headingAlign = dir\n  return this\n}\n\n/**\n * Add a row of information to the table\n * \n * @param {...|Array} argument values in order of columns\n * @api public\n */\n\nAsciiTable.prototype.addRow = function(row) {\n  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {\n    row = slice.call(arguments)\n  }\n  this.__maxCells = Math.max(this.__maxCells, row.length)\n  this.__rows.push(row)\n  return this\n}\n\n/**\n * Get a copy of all rows of the table\n *\n * @return {Array} copy of rows\n * @api public\n */\n\nAsciiTable.prototype.getRows = function() {\n  return this.__rows.slice().map(function(row) {\n    return row.slice()\n  })\n}\n\n/**\n * Add rows in the format of a row matrix\n *\n * @param {Array} row matrix\n * @api public\n */\n\nAsciiTable.prototype.addRowMatrix = function(rows) {\n  for (var i = 0; i < rows.length; i++) {\n    this.addRow(rows[i])\n  }\n  return this\n}\n\n/**\n * Add rows from the given data array, processed by the callback function rowCallback.\n *\n * @param {Array} data\n * @param (Function) rowCallback\n * @param (Boolean) asMatrix - controls if the row created by rowCallback should be assigned as row matrix\n * @api public\n */\n\nAsciiTable.prototype.addData = function(data, rowCallback, asMatrix) {\n  if (toString.call(data) !== '[object Array]') {\n    return this;\n  }\n  for (var index = 0, limit = data.length; index < limit; index++) {\n    var row = rowCallback(data[index]);\n    if(asMatrix) {\n      this.addRowMatrix(row);\n    } else {\n      this.addRow(row);\n    }\n  }\n  return this\n}\n\n  /**\n * Reset the current row state\n *\n * @api public\n */\n\nAsciiTable.prototype.clearRows = function() {\n  this.__rows = []\n  this.__maxCells = 0\n  this.__colMaxes = []\n  return this\n}\n\n/**\n * Apply an even spaced column justification\n *\n * @param {Boolean} on / off\n * @api public\n */\n\nAsciiTable.prototype.setJustify = function(val) {\n  arguments.length === 0 && (val = true)\n  this.__justify = !!val\n  return this\n}\n\n/**\n * Convert the current instance to a JSON structure\n *\n * @return {Object} json representation\n * @api public\n */\n\nAsciiTable.prototype.toJSON = function() {\n  return {\n    title: this.getTitle()\n  , heading: this.getHeading()\n  , rows: this.getRows()\n  }\n}\n\n/**\n * Populate the table from a JSON object\n *\n * @param {Object} json representation\n * @api public\n */\n\nAsciiTable.prototype.parse = \nAsciiTable.prototype.fromJSON = function(obj) {\n  return this\n    .clear()\n    .setTitle(obj.title)\n    .setHeading(obj.heading)\n    .addRowMatrix(obj.rows)\n}\n\n/**\n * Render the table with the current information\n *\n * @return {String} formatted table\n * @api public\n */\n\nAsciiTable.prototype.render =\nAsciiTable.prototype.valueOf =\nAsciiTable.prototype.toString = function() {\n  var self = this\n    , body = []\n    , mLen = this.__maxCells\n    , max = AsciiTable.arrayFill(mLen, 0)\n    , total = mLen * 3\n    , rows = this.__rows\n    , justify\n    , border = this.__border\n    , all = this.__heading \n        ? [this.__heading].concat(rows)\n        : rows\n\n  // Calculate max table cell lengths across all rows\n  for (var i = 0; i < all.length; i++) {\n    var row = all[i]\n    for (var k = 0; k < mLen; k++) {\n      var cell = row[k]\n      max[k] = Math.max(max[k], cell ? cell.toString().length : 0)\n    }\n  }\n  this.__colMaxes = max\n  justify = this.__justify ? Math.max.apply(null, max) : 0\n\n  // Get \n  max.forEach(function(x) {\n    total += justify ? justify : x + self.__spacing\n  })\n  justify && (total += max.length)\n  total -= this.__spacing\n\n  // Heading\n  border && body.push(this._seperator(total - mLen + 1, this.__top))\n  if (this.__name) {\n    body.push(this._renderTitle(total - mLen + 1))\n    border && body.push(this._seperator(total - mLen + 1))\n  }\n  if (this.__heading) {\n    body.push(this._renderRow(this.__heading, ' ', this.__headingAlign))\n    body.push(this._rowSeperator(mLen, this.__fill))\n  }\n  for (var i = 0; i < this.__rows.length; i++) {\n    body.push(this._renderRow(this.__rows[i], ' '))\n  }\n  border && body.push(this._seperator(total - mLen + 1, this.__bottom))\n\n  var prefix = this.options.prefix || ''\n  return prefix + body.join('\\n' + prefix)\n}\n\n/**\n * Create a line seperator\n *\n * @param {Number} string size\n * @param {String} side values (default '|')\n * @api private\n */\n\nAsciiTable.prototype._seperator = function(len, sep) {\n  sep || (sep = this.__edge)\n  return sep + AsciiTable.alignRight(sep, len, this.__fill)\n}\n\n/**\n * Create a row seperator\n *\n * @return {String} seperator\n * @api private\n */\n\nAsciiTable.prototype._rowSeperator = function() {\n  var blanks = AsciiTable.arrayFill(this.__maxCells, this.__fill)\n  return this._renderRow(blanks, this.__fill)\n}\n\n/**\n * Render the table title in a centered box\n *\n * @param {Number} string size\n * @return {String} formatted title\n * @api private\n */\n\nAsciiTable.prototype._renderTitle = function(len) {\n  var name = ' ' + this.__name + ' '\n    , str = AsciiTable.align(this.__nameAlign, name, len - 1, ' ')\n  return this.__edge + str + this.__edge\n}\n\n/**\n * Render an invdividual row\n *\n * @param {Array} row\n * @param {String} column seperator\n * @param {Number} total row alignment (optional, default `auto`)\n * @return {String} formatted row\n * @api private\n */\n\nAsciiTable.prototype._renderRow = function(row, str, align) {\n  var tmp = ['']\n    , max = this.__colMaxes\n\n  for (var k = 0; k < this.__maxCells; k++) {\n    var cell = row[k]\n      , just = this.__justify ? Math.max.apply(null, max) : max[k]\n      // , pad = k === this.__maxCells - 1 ? just : just + this.__spacing\n      , pad = just\n      , cAlign = this.__aligns[k]\n      , use = align\n      , method = 'alignAuto'\n  \n    if (typeof align === 'undefined') use = cAlign\n\n    if (use === AsciiTable.LEFT) method = 'alignLeft'\n    if (use === AsciiTable.CENTER) method = 'alignCenter'\n    if (use === AsciiTable.RIGHT) method = 'alignRight'\n\n    tmp.push(AsciiTable[method](cell, pad, str))\n  }\n  var front = tmp.join(str + this.__edge + str)\n  front = front.substr(1, front.length)\n  return front + str + this.__edge\n}\n\n/*!\n * Aliases\n */\n\n// Create method shortcuts to all alignment methods for each direction\n;['Left', 'Right', 'Center'].forEach(function(dir) {\n  var constant = AsciiTable[dir.toUpperCase()]\n\n  ;['setAlign', 'setTitleAlign', 'setHeadingAlign'].forEach(function(method) {\n    // Call the base method with the direction constant as the last argument\n    AsciiTable.prototype[method + dir] = function() {\n      var args = slice.call(arguments).concat(constant)\n      return this[method].apply(this, args)\n    }\n  })\n})\n\n/*!\n * Module exports.\n */\n\nif (typeof exports !== 'undefined') {\n  module.exports = AsciiTable\n} else {\n  this.AsciiTable = AsciiTable\n}\n\n}).call(this);\n"}],"actions":[]},{"type":"group","name":"Triggers","enabled":true,"id":9,"items":[{"type":"trigger","name":"","enabled":true,"id":51,"matching":"exact","whole_words":true,"case_sensitive":true,"text":"You settle into cold storage while the Starmourn sector awaits your return to space.","actions":[{"action":"script","script":"slt.hardSave();"}]},{"type":"trigger","name":"","enabled":true,"id":26,"matching":"regexp","whole_words":true,"case_sensitive":false,"text":"^Hacking Level:\\s*(\\d+)","actions":[{"action":"script","script":"if (slt.db[slt.currentRoom].level == null) {\n    slt.db[slt.currentRoom].level = args[1];\n    slt.hardSave();\n}"}]},{"type":"trigger","name":"","enabled":true,"id":31,"matching":"exact","whole_words":true,"case_sensitive":true,"text":"Your vision comes back into focus as your consciousness returns to your physical body.","actions":[{"action":"script","script":"if (typeof slt.gridscanResult !='undefined') slt.gridscanResult = undefined;\nslt.hacking = false;\nslt.password = undefined;\nslt.processorHere = false;\nsend_command('l');\nsend_command('hack terminal');\n"}]},{"type":"trigger","name":"","enabled":true,"id":45,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"You have already hacked this grid. Your access will remain valid for another (\\d+) seconds.","actions":[{"action":"script","script":"slt.hackTimer(slt.currentRoom, args[1]);"}]},{"type":"trigger","name":"","enabled":true,"id":44,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"As you attempt to access the terminal, you find your mindsim access has been temporarily revoked. You will be able to try again in (\\d+) seconds.","actions":[{"action":"script","script":"slt.hackTimer(slt.currentRoom, args[1], false, args[1]);"}]},{"type":"trigger","name":"","enabled":true,"id":46,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"GridScan\\.Result\\(\"(\\d+)\"\\)","actions":[{"action":"script","script":"if (!slt.settings.highlight_gridscan.val) return;\nvar result = parseInt(args[1]);\nif (typeof slt.gridscanResult == 'undefined') {\n    slt.gridscanResult = result;\n    colorize_current_line(0, 100, 'yellow')\n    return;\n}\nif (result > slt.gridscanResult) {\n    colorize_current_line(0, 100, 'red')\n} else if (result == slt.gridscanResult) {\n    colorize_current_line(0, 100, 'yellow')\n} else {\n    colorize_current_line(0, 100, 'green')\n}\nslt.gridscanResult = result;\n"}]},{"type":"trigger","name":"","enabled":true,"id":28,"matching":"regexp","whole_words":true,"case_sensitive":false,"text":"\\[ S \\| GigaOps: \\d+\\/\\d+ \\| Password: (.+) \\] ","actions":[{"action":"script","script":"//slt.verb('Checking for ne pw regex from match: ' + args[1]);\nvar pw = args[1].toLowerCase();\npw = pw.replace(/\\*/g,'.');\npw = \"^\" + pw + \"$\";\nslt.pwRe = new RegExp(pw);"}]},{"type":"trigger","name":"","enabled":true,"id":47,"matching":"regexp","whole_words":true,"case_sensitive":true,"text":"This terminal has been locked out due to a recent hacking attempt. You will be able to try again in (\\d+) seconds.","actions":[{"action":"script","script":"slt.hackTimer(slt.currentRoom, args[1], false, args[1]);"}]},{"type":"trigger","name":"","enabled":true,"id":52,"matching":"exact","whole_words":true,"case_sensitive":true,"text":"You enter the commsphere.","actions":[{"action":"script","script":"if (typeof slt.gridscanResult !='undefined') slt.gridscanResult = undefined;\nslt.hacking = true;\n"}]}],"actions":[]},{"type":"group","name":"Aliases","enabled":true,"id":10,"items":[{"type":"alias","name":"","enabled":true,"id":29,"matching":"exact","whole_words":true,"case_sensitive":false,"prefix_suffix":true,"actions":[{"action":"script","script":"if (!slt.hacking) {\n    slt.error('You must be in the commsphere to do that.')\n    return;\n}\nif (typeof slt.pwRe != 'object') {\n    slt.error('Error: no password hint found.')\n    return;\n}\nslt.verb('Starting search database with regex '+JSON.stringify(slt.pwRe));\nif (typeof slt.dictionary != 'undefined') {\n    slt.calcPassword();\n} else {\n    slt.loadDict(true);\n}"}],"text":"pass"},{"type":"alias","name":"","enabled":true,"id":25,"matching":"regexp","whole_words":true,"case_sensitive":false,"prefix_suffix":true,"actions":[{"action":"function","fn":"slt.main"},{"action":"function","fn":"slt.display"},{"action":"function","fn":"slt.utilities"},{"action":"function","fn":"slt.interface"},{"action":"function","fn":"slt.settings"},{"action":"function","fn":"slt.loadDict"},{"action":"function","fn":"slt.calcHere"},{"action":"function","fn":"ascii-tables"},{"action":"script","script":"/*var urls = [\n 'https://raw.githubusercontent.com/sorensen/ascii-table/master/ascii-table.js',\n]\n    \nvar p = $.when(1)\nurls.forEach(function(item, index) {\n  let a = item\n  p = p.then(function() {\n    return $.ajax({\n     url: a + '?v=' + new Date().getTime()\n    }).done(function(data) {\n      console.log('Trying eval(data) for ' + a + '.')\n      //console.log([data])\n      try {\n       eval(data)\n       slt.verb('Loaded Ascii Tables.')\n      } catch(err) { console.log(err) \n       slt.error('Error loading Ascii Tables.')}\n    }\n\n    )\n  })\n})\n*/\nif (typeof slt.timeouts != 'undefined') {\n    for (t in slt.timeouts) {\n        clearTimeout(slt.timeouts[t]);\n    }\n    delete slt.timeouts;\n}\nslt.timeouts = {};\n//slt.checkHackTimers();\nsetTimeout(slt.checkHackTimers,5000);\nslt.timerInterval();\nslt.interval;"}],"text":"^sltgo$"},{"type":"alias","name":"","enabled":true,"id":17,"matching":"regexp","whole_words":true,"case_sensitive":false,"prefix_suffix":true,"actions":[{"action":"script","script":"slt.interface({cmd:'slt'});"}],"text":"^slt\\s?$"},{"type":"alias","name":"","enabled":true,"id":24,"matching":"regexp","whole_words":true,"case_sensitive":false,"prefix_suffix":true,"actions":[{"action":"script","script":"\nvar match = args[1].split(' ');\nvar len = match.length;\nvar args = {};\nslt.verb('Interfacing + ' +len + 'matches: ' + JSON.stringify(match));\nswitch (len) {\n\tcase 1:\n\targs.cmd = match[0];\n\tslt.interface(args);\n\tbreak;\n\tcase 2:\n\targs.cmd = match[0];\n\targs.key = match[1];\n\tslt.interface(args);\n\tbreak;\n\tcase 3:\n\targs.cmd = match[0];\n\targs.key = match[1];\n\targs.val = match[2];\n\tslt.interface(args);\n\tbreak;\n\tcase 4:\n\targs.cmd = match[0];\n\targs.key = match[1];\n\targs.val = match[2];\n\targs.val2 = match[3];\n\tslt.interface(args);\n\tbreak;\n\tdefault:\n\targs.cmd = 'slt'\n\tslt.interface(args);\n\tbreak;\n}\n"}],"text":"^slt (.+)$"},{"type":"alias","name":"","enabled":true,"id":48,"matching":"exact","whole_words":true,"case_sensitive":false,"prefix_suffix":true,"actions":[{"action":"command","command":"hack terminal","prefix_suffix":true}],"text":"ht"}],"actions":[]}]}
